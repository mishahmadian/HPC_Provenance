# -*- coding: utf-8 -*-
"""
    RabbitMQ Interface: Send/publish the collected logs to
    the Monitoring server.

    Misha Ahmadian (misha.ahmadian@ttu.edu)
"""
from pika import PlainCredentials, ConnectionParameters, BlockingConnection, exceptions
from config import ServerConfig, ConfigReadExcetion
from enum import Enum

class ServerConnection:
    def __init__(self):
        try:
            self.config = ServerConfig()
            self.__server = self.config.getServer()
            self.__port = self.config.getPort()
            self.__username = self.config.getUsername()
            self.__password = self.config.getPassword()
            self.__Vhost = self.config.getVhost()

        except ConfigReadExcetion as confExp:
            raise CommunicationExp(confExp.getMessage(), CommunicationExp.Type.AMQP_CONFIG)

        # Create Credentilas with username/password
        self.__credentials = PlainCredentials(self.__username, self.__password)
        # Setup the connection parameters
        self.__params = ConnectionParameters(self.__server,
                                                self.__port,
                                                self.__Vhost,
                                                self.__credentials)

    # Establishe a Connection to RabbitMQ server
    def __openConnection(self):
        try:
            return BlockingConnection(self.__params)

        except (exceptions.ConnectionClosed, exceptions.AMQPConnectionError,
                exceptions.AMQPError) as amqExp:
            raise CommunicationExp("Connection was not established. {}".format(amqExp),
                                    CommunicationExp.Type.AMQP_CONN)

    # Open a channel on current connection to RabbitMQ server
    def __openChannel(self, conn):
        try:
            return conn.channel()

        except(exceptions.AMQPChannelError, exceptions.AMQPError) as amqExp:
            raise CommunicationExp("couldn't open a Channel. {})".format(amqExp),
                                    CommunicationExp.Type.AMQP_CHANL)
    # Close the Connection
    def __closeConnection(self, conn):
        try:
            conn.close()

        except exceptions.AMQPError as amqExp:
            raise CommunicationExp("Connection did not close Properly. {}".format(amqExp),
                                    CommunicationExp.Type.AMQP_CLOSE)

    #
    # Listen to the queue shared between server and qgents and collect
    # I/O statistics which are generated by agents and call the "callback"
    # function to handle the received data
    #
    def Collect_io_stats(self, callback):
        # Get IO Stat Listener Params
        queue = self.config.getIOListener_Queue()
        exchange = self.config.getIOListener_Exch()
        # Establish a Connection
        conn = self.__openConnection()
        # Open a Channel
        channel = self.__openChannel(conn)
        # Declare a direct Exchange for this listener
        channel.exchange_declare(exchange=exchange, exchange_type='direct')
        # Declare the queue
        channel.queue_declare(queue=queue)
        # Bind Queue to Exchange
        channel.queue_bind(exchange=exchange, queue=queue)
        # sets up the consumer prefetch to only be delivered one message
        # at a time. The consumer must acknowledge this message before
        # RabbitMQ will deliver another one.
        channel.basic_qos(prefetch_count=1)
        # Set basic consumer with a "callback" function
        channel.basic_consume(queue=queue, on_message_callback=callback, auto_ack=True)
        # Start consuming: Listening to the channel and collecting the
        # incoming IO stats from agents
        channel.start_consuming()
        #while channel._consumer_infos:
        #    channel.connection.process_data_events(time_limit=1)
        #
        return conn, channel

#
# In any case of Error, Exception, or Mistake ConfigReadExcetion will be raised
#
class CommunicationExp(Exception):
    def __init__(self, message, expType):
        super(CommunicationExp, self).__init__(message)
        self.message = message
        self.expType = expType

    def getMessage(self):
        return "\n [Error] _{}_: {} \n".format(self.expType.name, self.message)

    #
    # Communication Exception may have different causes
    class Type(Enum):
        AMQP_CONFIG = 1
        AMQP_CONN = 2
        AMQP_CHANL = 3
        AMQP_CLOSE = 4
